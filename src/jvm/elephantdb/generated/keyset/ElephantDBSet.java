/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package elephantdb.generated.keyset;

import org.apache.commons.lang.builder.HashCodeBuilder;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

import com.twitter.util.Future;
import com.twitter.util.Function;
import com.twitter.util.Function2;
import com.twitter.util.Try;
import com.twitter.util.Return;
import com.twitter.util.Throw;
import com.twitter.finagle.thrift.ThriftClientRequest;

public class ElephantDBSet {

  public interface Iface extends elephantdb.generated.ElephantDBShared.Iface {

    public boolean member(String domain, String setKey, String member) throws TException;

    public boolean members(String domain, String setKey) throws TException;

    public List<String> setDiff(String domain, String keyOne, String keyTwo) throws TException;

    public List<String> setUnion(String domain, String keyOne, String keyTwo) throws TException;

    public List<String> setIntersection(String domain, String keyOne, String keyTwo) throws TException;

    public long size(String domain, String key) throws TException;

    public List<elephantdb.generated.Value> multiMember(String domain, String setKey, List<String> setVals) throws TException;

  }

  public interface AsyncIface extends elephantdb.generated.ElephantDBShared.AsyncIface {

    public void member(String domain, String setKey, String member, AsyncMethodCallback<AsyncClient.member_call> resultHandler) throws TException;

    public void members(String domain, String setKey, AsyncMethodCallback<AsyncClient.members_call> resultHandler) throws TException;

    public void setDiff(String domain, String keyOne, String keyTwo, AsyncMethodCallback<AsyncClient.setDiff_call> resultHandler) throws TException;

    public void setUnion(String domain, String keyOne, String keyTwo, AsyncMethodCallback<AsyncClient.setUnion_call> resultHandler) throws TException;

    public void setIntersection(String domain, String keyOne, String keyTwo, AsyncMethodCallback<AsyncClient.setIntersection_call> resultHandler) throws TException;

    public void size(String domain, String key, AsyncMethodCallback<AsyncClient.size_call> resultHandler) throws TException;

    public void multiMember(String domain, String setKey, List<String> setVals, AsyncMethodCallback<AsyncClient.multiMember_call> resultHandler) throws TException;

  }

  public interface ServiceIface extends elephantdb.generated.ElephantDBShared.ServiceIface {

    public Future<Boolean> member(String domain, String setKey, String member);

    public Future<Boolean> members(String domain, String setKey);

    public Future<List<String>> setDiff(String domain, String keyOne, String keyTwo);

    public Future<List<String>> setUnion(String domain, String keyOne, String keyTwo);

    public Future<List<String>> setIntersection(String domain, String keyOne, String keyTwo);

    public Future<Long> size(String domain, String key);

    public Future<List<elephantdb.generated.Value>> multiMember(String domain, String setKey, List<String> setVals);

  }

  public static class Client extends elephantdb.generated.ElephantDBShared.Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      super(iprot, oprot);
    }

    public boolean member(String domain, String setKey, String member) throws TException
    {
      send_member(domain, setKey, member);
      return recv_member();
    }

    public void send_member(String domain, String setKey, String member) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("member", TMessageType.CALL, ++seqid_));
      member_args args = new member_args();
      args.set_domain(domain);
      args.set_setKey(setKey);
      args.set_member(member);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_member() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "member failed: out of sequence response");
      }
      member_result result = new member_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "member failed: unknown result");
    }

    public boolean members(String domain, String setKey) throws TException
    {
      send_members(domain, setKey);
      return recv_members();
    }

    public void send_members(String domain, String setKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("members", TMessageType.CALL, ++seqid_));
      members_args args = new members_args();
      args.set_domain(domain);
      args.set_setKey(setKey);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_members() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "members failed: out of sequence response");
      }
      members_result result = new members_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "members failed: unknown result");
    }

    public List<String> setDiff(String domain, String keyOne, String keyTwo) throws TException
    {
      send_setDiff(domain, keyOne, keyTwo);
      return recv_setDiff();
    }

    public void send_setDiff(String domain, String keyOne, String keyTwo) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setDiff", TMessageType.CALL, ++seqid_));
      setDiff_args args = new setDiff_args();
      args.set_domain(domain);
      args.set_keyOne(keyOne);
      args.set_keyTwo(keyTwo);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_setDiff() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setDiff failed: out of sequence response");
      }
      setDiff_result result = new setDiff_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setDiff failed: unknown result");
    }

    public List<String> setUnion(String domain, String keyOne, String keyTwo) throws TException
    {
      send_setUnion(domain, keyOne, keyTwo);
      return recv_setUnion();
    }

    public void send_setUnion(String domain, String keyOne, String keyTwo) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setUnion", TMessageType.CALL, ++seqid_));
      setUnion_args args = new setUnion_args();
      args.set_domain(domain);
      args.set_keyOne(keyOne);
      args.set_keyTwo(keyTwo);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_setUnion() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setUnion failed: out of sequence response");
      }
      setUnion_result result = new setUnion_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setUnion failed: unknown result");
    }

    public List<String> setIntersection(String domain, String keyOne, String keyTwo) throws TException
    {
      send_setIntersection(domain, keyOne, keyTwo);
      return recv_setIntersection();
    }

    public void send_setIntersection(String domain, String keyOne, String keyTwo) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setIntersection", TMessageType.CALL, ++seqid_));
      setIntersection_args args = new setIntersection_args();
      args.set_domain(domain);
      args.set_keyOne(keyOne);
      args.set_keyTwo(keyTwo);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_setIntersection() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setIntersection failed: out of sequence response");
      }
      setIntersection_result result = new setIntersection_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setIntersection failed: unknown result");
    }

    public long size(String domain, String key) throws TException
    {
      send_size(domain, key);
      return recv_size();
    }

    public void send_size(String domain, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("size", TMessageType.CALL, ++seqid_));
      size_args args = new size_args();
      args.set_domain(domain);
      args.set_key(key);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_size() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "size failed: out of sequence response");
      }
      size_result result = new size_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "size failed: unknown result");
    }

    public List<elephantdb.generated.Value> multiMember(String domain, String setKey, List<String> setVals) throws TException
    {
      send_multiMember(domain, setKey, setVals);
      return recv_multiMember();
    }

    public void send_multiMember(String domain, String setKey, List<String> setVals) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("multiMember", TMessageType.CALL, ++seqid_));
      multiMember_args args = new multiMember_args();
      args.set_domain(domain);
      args.set_setKey(setKey);
      args.set_setVals(setVals);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<elephantdb.generated.Value> recv_multiMember() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "multiMember failed: out of sequence response");
      }
      multiMember_result result = new multiMember_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiMember failed: unknown result");
    }

  }
  public static class AsyncClient extends elephantdb.generated.ElephantDBShared.AsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void member(String domain, String setKey, String member, AsyncMethodCallback<member_call> resultHandler) throws TException {
      checkReady();
      member_call method_call = new member_call(domain, setKey, member, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class member_call extends TAsyncMethodCall {
      private String domain;
      private String setKey;
      private String member;
      public member_call(String domain, String setKey, String member, AsyncMethodCallback<member_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.setKey = setKey;
        this.member = member;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("member", TMessageType.CALL, 0));
        member_args args = new member_args();
        args.set_domain(domain);
        args.set_setKey(setKey);
        args.set_member(member);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_member();
      }
    }

    public void members(String domain, String setKey, AsyncMethodCallback<members_call> resultHandler) throws TException {
      checkReady();
      members_call method_call = new members_call(domain, setKey, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class members_call extends TAsyncMethodCall {
      private String domain;
      private String setKey;
      public members_call(String domain, String setKey, AsyncMethodCallback<members_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.setKey = setKey;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("members", TMessageType.CALL, 0));
        members_args args = new members_args();
        args.set_domain(domain);
        args.set_setKey(setKey);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_members();
      }
    }

    public void setDiff(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setDiff_call> resultHandler) throws TException {
      checkReady();
      setDiff_call method_call = new setDiff_call(domain, keyOne, keyTwo, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setDiff_call extends TAsyncMethodCall {
      private String domain;
      private String keyOne;
      private String keyTwo;
      public setDiff_call(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setDiff_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.keyOne = keyOne;
        this.keyTwo = keyTwo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setDiff", TMessageType.CALL, 0));
        setDiff_args args = new setDiff_args();
        args.set_domain(domain);
        args.set_keyOne(keyOne);
        args.set_keyTwo(keyTwo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setDiff();
      }
    }

    public void setUnion(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setUnion_call> resultHandler) throws TException {
      checkReady();
      setUnion_call method_call = new setUnion_call(domain, keyOne, keyTwo, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setUnion_call extends TAsyncMethodCall {
      private String domain;
      private String keyOne;
      private String keyTwo;
      public setUnion_call(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setUnion_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.keyOne = keyOne;
        this.keyTwo = keyTwo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setUnion", TMessageType.CALL, 0));
        setUnion_args args = new setUnion_args();
        args.set_domain(domain);
        args.set_keyOne(keyOne);
        args.set_keyTwo(keyTwo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setUnion();
      }
    }

    public void setIntersection(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setIntersection_call> resultHandler) throws TException {
      checkReady();
      setIntersection_call method_call = new setIntersection_call(domain, keyOne, keyTwo, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setIntersection_call extends TAsyncMethodCall {
      private String domain;
      private String keyOne;
      private String keyTwo;
      public setIntersection_call(String domain, String keyOne, String keyTwo, AsyncMethodCallback<setIntersection_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.keyOne = keyOne;
        this.keyTwo = keyTwo;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setIntersection", TMessageType.CALL, 0));
        setIntersection_args args = new setIntersection_args();
        args.set_domain(domain);
        args.set_keyOne(keyOne);
        args.set_keyTwo(keyTwo);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_setIntersection();
      }
    }

    public void size(String domain, String key, AsyncMethodCallback<size_call> resultHandler) throws TException {
      checkReady();
      size_call method_call = new size_call(domain, key, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class size_call extends TAsyncMethodCall {
      private String domain;
      private String key;
      public size_call(String domain, String key, AsyncMethodCallback<size_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.key = key;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("size", TMessageType.CALL, 0));
        size_args args = new size_args();
        args.set_domain(domain);
        args.set_key(key);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_size();
      }
    }

    public void multiMember(String domain, String setKey, List<String> setVals, AsyncMethodCallback<multiMember_call> resultHandler) throws TException {
      checkReady();
      multiMember_call method_call = new multiMember_call(domain, setKey, setVals, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class multiMember_call extends TAsyncMethodCall {
      private String domain;
      private String setKey;
      private List<String> setVals;
      public multiMember_call(String domain, String setKey, List<String> setVals, AsyncMethodCallback<multiMember_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.domain = domain;
        this.setKey = setKey;
        this.setVals = setVals;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("multiMember", TMessageType.CALL, 0));
        multiMember_args args = new multiMember_args();
        args.set_domain(domain);
        args.set_setKey(setKey);
        args.set_setVals(setVals);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<elephantdb.generated.Value> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_multiMember();
      }
    }

  }

  public static class ServiceToClient extends elephantdb.generated.ElephantDBShared.ServiceToClient implements ServiceIface {
    private com.twitter.finagle.Service<ThriftClientRequest, byte[]> service;
    private TProtocolFactory protocolFactory;
    public ServiceToClient(com.twitter.finagle.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory) {
      super(service, protocolFactory);
      this.service = service;
      this.protocolFactory = protocolFactory;
    }

    public Future<Boolean> member(String domain, String setKey, String member) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("member", TMessageType.CALL, 0));
        member_args __args__ = new member_args();
        __args__.set_domain(domain);
        __args__.set_setKey(setKey);
        __args__.set_member(member);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Boolean>>() {
          public Future<Boolean> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_member());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Boolean> members(String domain, String setKey) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("members", TMessageType.CALL, 0));
        members_args __args__ = new members_args();
        __args__.set_domain(domain);
        __args__.set_setKey(setKey);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Boolean>>() {
          public Future<Boolean> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_members());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<String>> setDiff(String domain, String keyOne, String keyTwo) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("setDiff", TMessageType.CALL, 0));
        setDiff_args __args__ = new setDiff_args();
        __args__.set_domain(domain);
        __args__.set_keyOne(keyOne);
        __args__.set_keyTwo(keyTwo);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<String>>>() {
          public Future<List<String>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_setDiff());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<String>> setUnion(String domain, String keyOne, String keyTwo) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("setUnion", TMessageType.CALL, 0));
        setUnion_args __args__ = new setUnion_args();
        __args__.set_domain(domain);
        __args__.set_keyOne(keyOne);
        __args__.set_keyTwo(keyTwo);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<String>>>() {
          public Future<List<String>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_setUnion());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<String>> setIntersection(String domain, String keyOne, String keyTwo) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("setIntersection", TMessageType.CALL, 0));
        setIntersection_args __args__ = new setIntersection_args();
        __args__.set_domain(domain);
        __args__.set_keyOne(keyOne);
        __args__.set_keyTwo(keyTwo);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<String>>>() {
          public Future<List<String>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_setIntersection());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Long> size(String domain, String key) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("size", TMessageType.CALL, 0));
        size_args __args__ = new size_args();
        __args__.set_domain(domain);
        __args__.set_key(key);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Long>>() {
          public Future<Long> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_size());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<elephantdb.generated.Value>> multiMember(String domain, String setKey, List<String> setVals) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("multiMember", TMessageType.CALL, 0));
        multiMember_args __args__ = new multiMember_args();
        __args__.set_domain(domain);
        __args__.set_setKey(setKey);
        __args__.set_setVals(setVals);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<elephantdb.generated.Value>>>() {
          public Future<List<elephantdb.generated.Value>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_multiMember());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
  }

  public static class Processor extends elephantdb.generated.ElephantDBShared.Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      super(iface);
      iface_ = iface;
      processMap_.put("member", new member());
      processMap_.put("members", new members());
      processMap_.put("setDiff", new setDiff());
      processMap_.put("setUnion", new setUnion());
      processMap_.put("setIntersection", new setIntersection());
      processMap_.put("size", new size());
      processMap_.put("multiMember", new multiMember());
    }

    private Iface iface_;

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class member implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        member_args args = new member_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("member", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        member_result result = new member_result();
        result.success = iface_.member(args.domain, args.setKey, args.member);
        result.set_success_isSet(true);
        oprot.writeMessageBegin(new TMessage("member", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class members implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        members_args args = new members_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("members", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        members_result result = new members_result();
        result.success = iface_.members(args.domain, args.setKey);
        result.set_success_isSet(true);
        oprot.writeMessageBegin(new TMessage("members", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setDiff implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setDiff_args args = new setDiff_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setDiff", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setDiff_result result = new setDiff_result();
        result.success = iface_.setDiff(args.domain, args.keyOne, args.keyTwo);
        oprot.writeMessageBegin(new TMessage("setDiff", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setUnion implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setUnion_args args = new setUnion_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setUnion", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setUnion_result result = new setUnion_result();
        result.success = iface_.setUnion(args.domain, args.keyOne, args.keyTwo);
        oprot.writeMessageBegin(new TMessage("setUnion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setIntersection implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setIntersection_args args = new setIntersection_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setIntersection", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setIntersection_result result = new setIntersection_result();
        result.success = iface_.setIntersection(args.domain, args.keyOne, args.keyTwo);
        oprot.writeMessageBegin(new TMessage("setIntersection", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class size implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        size_args args = new size_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("size", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        size_result result = new size_result();
        result.success = iface_.size(args.domain, args.key);
        result.set_success_isSet(true);
        oprot.writeMessageBegin(new TMessage("size", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class multiMember implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        multiMember_args args = new multiMember_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("multiMember", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        multiMember_result result = new multiMember_result();
        result.success = iface_.multiMember(args.domain, args.setKey, args.setVals);
        oprot.writeMessageBegin(new TMessage("multiMember", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class Service extends elephantdb.generated.ElephantDBShared.Service {
    private final ServiceIface iface;
    private final TProtocolFactory protocolFactory;
    public Service(final ServiceIface iface, final TProtocolFactory protocolFactory) {
      super(iface, protocolFactory);
      this.iface = iface;
      this.protocolFactory = protocolFactory;
      functionMap.put("member", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          member_args args = new member_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("member", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Boolean> future;
          try {
            future = iface.member(args.domain, args.setKey, args.member);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Boolean, Future<byte[]>>() {
              public Future<byte[]> apply(Boolean value) {
                member_result result = new member_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("member", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("members", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          members_args args = new members_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("members", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Boolean> future;
          try {
            future = iface.members(args.domain, args.setKey);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Boolean, Future<byte[]>>() {
              public Future<byte[]> apply(Boolean value) {
                members_result result = new members_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("members", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("setDiff", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          setDiff_args args = new setDiff_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("setDiff", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<String>> future;
          try {
            future = iface.setDiff(args.domain, args.keyOne, args.keyTwo);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<String>, Future<byte[]>>() {
              public Future<byte[]> apply(List<String> value) {
                setDiff_result result = new setDiff_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("setDiff", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("setUnion", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          setUnion_args args = new setUnion_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("setUnion", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<String>> future;
          try {
            future = iface.setUnion(args.domain, args.keyOne, args.keyTwo);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<String>, Future<byte[]>>() {
              public Future<byte[]> apply(List<String> value) {
                setUnion_result result = new setUnion_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("setUnion", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("setIntersection", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          setIntersection_args args = new setIntersection_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("setIntersection", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<String>> future;
          try {
            future = iface.setIntersection(args.domain, args.keyOne, args.keyTwo);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<String>, Future<byte[]>>() {
              public Future<byte[]> apply(List<String> value) {
                setIntersection_result result = new setIntersection_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("setIntersection", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("size", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          size_args args = new size_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("size", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Long> future;
          try {
            future = iface.size(args.domain, args.key);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Long, Future<byte[]>>() {
              public Future<byte[]> apply(Long value) {
                size_result result = new size_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("size", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("multiMember", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          multiMember_args args = new multiMember_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("multiMember", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<elephantdb.generated.Value>> future;
          try {
            future = iface.multiMember(args.domain, args.setKey, args.setVals);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<elephantdb.generated.Value>, Future<byte[]>>() {
              public Future<byte[]> apply(List<elephantdb.generated.Value> value) {
                multiMember_result result = new multiMember_result();
                result.success = value;
                result.set_success_isSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("multiMember", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
    }
    
    public Future<byte[]> apply(byte[] request) {
      TTransport inputTransport = new TMemoryInputTransport(request);
      TProtocol iprot = protocolFactory.getProtocol(inputTransport);
    
      TMessage msg;
      try {
        msg = iprot.readMessageBegin();
      } catch (Exception e) {
        return Future.exception(e);
      }
    
      Function2<TProtocol, Integer, Future<byte[]>> fn = functionMap.get(msg.name);
      if (fn == null) {
        try {
          TProtocolUtil.skip(iprot, TType.STRUCT);
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
          TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
          TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
        } catch (Exception e) {
          return Future.exception(e);
        }
      }
    
      return fn.apply(iprot, msg.seqid);
    }

  }

  public static class member_args implements TBase<member_args, member_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("member_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField SET_KEY_FIELD_DESC = new TField("setKey", TType.STRING, (short)2);
    private static final TField MEMBER_FIELD_DESC = new TField("member", TType.STRING, (short)3);

    private String domain;
    private String setKey;
    private String member;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      SET_KEY((short)2, "setKey"),
      MEMBER((short)3, "member");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // SET_KEY
            return SET_KEY;
          case 3: // MEMBER
            return MEMBER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SET_KEY, new FieldMetaData("setKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.MEMBER, new FieldMetaData("member", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(member_args.class, metaDataMap);
    }

    public member_args() {
    }

    public member_args(
      String domain,
      String setKey,
      String member)
    {
      this();
      this.domain = domain;
      this.setKey = setKey;
      this.member = member;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public member_args(member_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_setKey()) {
        this.setKey = other.setKey;
      }
      if (other.is_set_member()) {
        this.member = other.member;
      }
    }

    public member_args deepCopy() {
      return new member_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.setKey = null;
      this.member = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_setKey() {
      return this.setKey;
    }

    public void set_setKey(String setKey) {
      this.setKey = setKey;
    }

    public void unset_setKey() {
      this.setKey = null;
    }

    /** Returns true if field setKey is set (has been asigned a value) and false otherwise */
    public boolean is_set_setKey() {
      return this.setKey != null;
    }

    public void set_setKey_isSet(boolean value) {
      if (!value) {
        this.setKey = null;
      }
    }

    public String get_member() {
      return this.member;
    }

    public void set_member(String member) {
      this.member = member;
    }

    public void unset_member() {
      this.member = null;
    }

    /** Returns true if field member is set (has been asigned a value) and false otherwise */
    public boolean is_set_member() {
      return this.member != null;
    }

    public void set_member_isSet(boolean value) {
      if (!value) {
        this.member = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case SET_KEY:
        if (value == null) {
          unset_setKey();
        } else {
          set_setKey((String)value);
        }
        break;

      case MEMBER:
        if (value == null) {
          unset_member();
        } else {
          set_member((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case SET_KEY:
        return get_setKey();

      case MEMBER:
        return get_member();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case SET_KEY:
        return is_set_setKey();
      case MEMBER:
        return is_set_member();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof member_args)
        return this.equals((member_args)that);
      return false;
    }

    public boolean equals(member_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_setKey = true && this.is_set_setKey();
      boolean that_present_setKey = true && that.is_set_setKey();
      if (this_present_setKey || that_present_setKey) {
        if (!(this_present_setKey && that_present_setKey))
          return false;
        if (!this.setKey.equals(that.setKey))
          return false;
      }

      boolean this_present_member = true && this.is_set_member();
      boolean that_present_member = true && that.is_set_member();
      if (this_present_member || that_present_member) {
        if (!(this_present_member && that_present_member))
          return false;
        if (!this.member.equals(that.member))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_setKey = true && (is_set_setKey());
      builder.append(present_setKey);
      if (present_setKey)
        builder.append(setKey);

      boolean present_member = true && (is_set_member());
      builder.append(present_member);
      if (present_member)
        builder.append(member);

      return builder.toHashCode();
    }

    public int compareTo(member_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      member_args typedOther = (member_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_setKey()).compareTo(typedOther.is_set_setKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_setKey()) {
        lastComparison = TBaseHelper.compareTo(this.setKey, typedOther.setKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_member()).compareTo(typedOther.is_set_member());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_member()) {
        lastComparison = TBaseHelper.compareTo(this.member, typedOther.member);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SET_KEY
            if (field.type == TType.STRING) {
              this.setKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // MEMBER
            if (field.type == TType.STRING) {
              this.member = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.setKey != null) {
        oprot.writeFieldBegin(SET_KEY_FIELD_DESC);
        oprot.writeString(this.setKey);
        oprot.writeFieldEnd();
      }
      if (this.member != null) {
        oprot.writeFieldBegin(MEMBER_FIELD_DESC);
        oprot.writeString(this.member);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("member_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("setKey:");
      if (this.setKey == null) {
        sb.append("null");
      } else {
        sb.append(this.setKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("member:");
      if (this.member == null) {
        sb.append("null");
      } else {
        sb.append(this.member);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class member_result implements TBase<member_result, member_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("member_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    private boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(member_result.class, metaDataMap);
    }

    public member_result() {
    }

    public member_result(
      boolean success)
    {
      this();
      this.success = success;
      set_success_isSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public member_result(member_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public member_result deepCopy() {
      return new member_result(this);
    }

    @Override
    public void clear() {
      set_success_isSet(false);
      this.success = false;
    }

    public boolean is_success() {
      return this.success;
    }

    public void set_success(boolean success) {
      this.success = success;
      set_success_isSet(true);
    }

    public void unset_success() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void set_success_isSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(is_success());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof member_result)
        return this.equals((member_result)that);
      return false;
    }

    public boolean equals(member_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true;
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(member_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      member_result typedOther = (member_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              set_success_isSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("member_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class members_args implements TBase<members_args, members_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("members_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField SET_KEY_FIELD_DESC = new TField("setKey", TType.STRING, (short)2);

    private String domain;
    private String setKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      SET_KEY((short)2, "setKey");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // SET_KEY
            return SET_KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SET_KEY, new FieldMetaData("setKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(members_args.class, metaDataMap);
    }

    public members_args() {
    }

    public members_args(
      String domain,
      String setKey)
    {
      this();
      this.domain = domain;
      this.setKey = setKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public members_args(members_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_setKey()) {
        this.setKey = other.setKey;
      }
    }

    public members_args deepCopy() {
      return new members_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.setKey = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_setKey() {
      return this.setKey;
    }

    public void set_setKey(String setKey) {
      this.setKey = setKey;
    }

    public void unset_setKey() {
      this.setKey = null;
    }

    /** Returns true if field setKey is set (has been asigned a value) and false otherwise */
    public boolean is_set_setKey() {
      return this.setKey != null;
    }

    public void set_setKey_isSet(boolean value) {
      if (!value) {
        this.setKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case SET_KEY:
        if (value == null) {
          unset_setKey();
        } else {
          set_setKey((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case SET_KEY:
        return get_setKey();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case SET_KEY:
        return is_set_setKey();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof members_args)
        return this.equals((members_args)that);
      return false;
    }

    public boolean equals(members_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_setKey = true && this.is_set_setKey();
      boolean that_present_setKey = true && that.is_set_setKey();
      if (this_present_setKey || that_present_setKey) {
        if (!(this_present_setKey && that_present_setKey))
          return false;
        if (!this.setKey.equals(that.setKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_setKey = true && (is_set_setKey());
      builder.append(present_setKey);
      if (present_setKey)
        builder.append(setKey);

      return builder.toHashCode();
    }

    public int compareTo(members_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      members_args typedOther = (members_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_setKey()).compareTo(typedOther.is_set_setKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_setKey()) {
        lastComparison = TBaseHelper.compareTo(this.setKey, typedOther.setKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SET_KEY
            if (field.type == TType.STRING) {
              this.setKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.setKey != null) {
        oprot.writeFieldBegin(SET_KEY_FIELD_DESC);
        oprot.writeString(this.setKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("members_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("setKey:");
      if (this.setKey == null) {
        sb.append("null");
      } else {
        sb.append(this.setKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class members_result implements TBase<members_result, members_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("members_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    private boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(members_result.class, metaDataMap);
    }

    public members_result() {
    }

    public members_result(
      boolean success)
    {
      this();
      this.success = success;
      set_success_isSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public members_result(members_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public members_result deepCopy() {
      return new members_result(this);
    }

    @Override
    public void clear() {
      set_success_isSet(false);
      this.success = false;
    }

    public boolean is_success() {
      return this.success;
    }

    public void set_success(boolean success) {
      this.success = success;
      set_success_isSet(true);
    }

    public void unset_success() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void set_success_isSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(is_success());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof members_result)
        return this.equals((members_result)that);
      return false;
    }

    public boolean equals(members_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true;
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(members_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      members_result typedOther = (members_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              set_success_isSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("members_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setDiff_args implements TBase<setDiff_args, setDiff_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setDiff_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField KEY_ONE_FIELD_DESC = new TField("keyOne", TType.STRING, (short)2);
    private static final TField KEY_TWO_FIELD_DESC = new TField("keyTwo", TType.STRING, (short)3);

    private String domain;
    private String keyOne;
    private String keyTwo;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      KEY_ONE((short)2, "keyOne"),
      KEY_TWO((short)3, "keyTwo");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // KEY_ONE
            return KEY_ONE;
          case 3: // KEY_TWO
            return KEY_TWO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_ONE, new FieldMetaData("keyOne", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_TWO, new FieldMetaData("keyTwo", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setDiff_args.class, metaDataMap);
    }

    public setDiff_args() {
    }

    public setDiff_args(
      String domain,
      String keyOne,
      String keyTwo)
    {
      this();
      this.domain = domain;
      this.keyOne = keyOne;
      this.keyTwo = keyTwo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setDiff_args(setDiff_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_keyOne()) {
        this.keyOne = other.keyOne;
      }
      if (other.is_set_keyTwo()) {
        this.keyTwo = other.keyTwo;
      }
    }

    public setDiff_args deepCopy() {
      return new setDiff_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.keyOne = null;
      this.keyTwo = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_keyOne() {
      return this.keyOne;
    }

    public void set_keyOne(String keyOne) {
      this.keyOne = keyOne;
    }

    public void unset_keyOne() {
      this.keyOne = null;
    }

    /** Returns true if field keyOne is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyOne() {
      return this.keyOne != null;
    }

    public void set_keyOne_isSet(boolean value) {
      if (!value) {
        this.keyOne = null;
      }
    }

    public String get_keyTwo() {
      return this.keyTwo;
    }

    public void set_keyTwo(String keyTwo) {
      this.keyTwo = keyTwo;
    }

    public void unset_keyTwo() {
      this.keyTwo = null;
    }

    /** Returns true if field keyTwo is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyTwo() {
      return this.keyTwo != null;
    }

    public void set_keyTwo_isSet(boolean value) {
      if (!value) {
        this.keyTwo = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case KEY_ONE:
        if (value == null) {
          unset_keyOne();
        } else {
          set_keyOne((String)value);
        }
        break;

      case KEY_TWO:
        if (value == null) {
          unset_keyTwo();
        } else {
          set_keyTwo((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case KEY_ONE:
        return get_keyOne();

      case KEY_TWO:
        return get_keyTwo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case KEY_ONE:
        return is_set_keyOne();
      case KEY_TWO:
        return is_set_keyTwo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setDiff_args)
        return this.equals((setDiff_args)that);
      return false;
    }

    public boolean equals(setDiff_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_keyOne = true && this.is_set_keyOne();
      boolean that_present_keyOne = true && that.is_set_keyOne();
      if (this_present_keyOne || that_present_keyOne) {
        if (!(this_present_keyOne && that_present_keyOne))
          return false;
        if (!this.keyOne.equals(that.keyOne))
          return false;
      }

      boolean this_present_keyTwo = true && this.is_set_keyTwo();
      boolean that_present_keyTwo = true && that.is_set_keyTwo();
      if (this_present_keyTwo || that_present_keyTwo) {
        if (!(this_present_keyTwo && that_present_keyTwo))
          return false;
        if (!this.keyTwo.equals(that.keyTwo))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_keyOne = true && (is_set_keyOne());
      builder.append(present_keyOne);
      if (present_keyOne)
        builder.append(keyOne);

      boolean present_keyTwo = true && (is_set_keyTwo());
      builder.append(present_keyTwo);
      if (present_keyTwo)
        builder.append(keyTwo);

      return builder.toHashCode();
    }

    public int compareTo(setDiff_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setDiff_args typedOther = (setDiff_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyOne()).compareTo(typedOther.is_set_keyOne());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyOne()) {
        lastComparison = TBaseHelper.compareTo(this.keyOne, typedOther.keyOne);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyTwo()).compareTo(typedOther.is_set_keyTwo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyTwo()) {
        lastComparison = TBaseHelper.compareTo(this.keyTwo, typedOther.keyTwo);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // KEY_ONE
            if (field.type == TType.STRING) {
              this.keyOne = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // KEY_TWO
            if (field.type == TType.STRING) {
              this.keyTwo = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.keyOne != null) {
        oprot.writeFieldBegin(KEY_ONE_FIELD_DESC);
        oprot.writeString(this.keyOne);
        oprot.writeFieldEnd();
      }
      if (this.keyTwo != null) {
        oprot.writeFieldBegin(KEY_TWO_FIELD_DESC);
        oprot.writeString(this.keyTwo);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setDiff_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyOne:");
      if (this.keyOne == null) {
        sb.append("null");
      } else {
        sb.append(this.keyOne);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyTwo:");
      if (this.keyTwo == null) {
        sb.append("null");
      } else {
        sb.append(this.keyTwo);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setDiff_result implements TBase<setDiff_result, setDiff_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setDiff_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    private List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setDiff_result.class, metaDataMap);
    }

    public setDiff_result() {
    }

    public setDiff_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setDiff_result(setDiff_result other) {
      if (other.is_set_success()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public setDiff_result deepCopy() {
      return new setDiff_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public int get_success_size() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> get_success_iterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void add_to_success(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> get_success() {
      return this.success;
    }

    public void set_success(List<String> success) {
      this.success = success;
    }

    public void unset_success() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return this.success != null;
    }

    public void set_success_isSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return get_success();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setDiff_result)
        return this.equals((setDiff_result)that);
      return false;
    }

    public boolean equals(setDiff_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.is_set_success();
      boolean that_present_success = true && that.is_set_success();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (is_set_success());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(setDiff_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setDiff_result typedOther = (setDiff_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list0 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list0.size);
                for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                {
                  String _elem2;
                  _elem2 = iprot.readString();
                  this.success.add(_elem2);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter3 : this.success)
          {
            oprot.writeString(_iter3);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setDiff_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setUnion_args implements TBase<setUnion_args, setUnion_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setUnion_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField KEY_ONE_FIELD_DESC = new TField("keyOne", TType.STRING, (short)2);
    private static final TField KEY_TWO_FIELD_DESC = new TField("keyTwo", TType.STRING, (short)3);

    private String domain;
    private String keyOne;
    private String keyTwo;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      KEY_ONE((short)2, "keyOne"),
      KEY_TWO((short)3, "keyTwo");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // KEY_ONE
            return KEY_ONE;
          case 3: // KEY_TWO
            return KEY_TWO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_ONE, new FieldMetaData("keyOne", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_TWO, new FieldMetaData("keyTwo", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setUnion_args.class, metaDataMap);
    }

    public setUnion_args() {
    }

    public setUnion_args(
      String domain,
      String keyOne,
      String keyTwo)
    {
      this();
      this.domain = domain;
      this.keyOne = keyOne;
      this.keyTwo = keyTwo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setUnion_args(setUnion_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_keyOne()) {
        this.keyOne = other.keyOne;
      }
      if (other.is_set_keyTwo()) {
        this.keyTwo = other.keyTwo;
      }
    }

    public setUnion_args deepCopy() {
      return new setUnion_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.keyOne = null;
      this.keyTwo = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_keyOne() {
      return this.keyOne;
    }

    public void set_keyOne(String keyOne) {
      this.keyOne = keyOne;
    }

    public void unset_keyOne() {
      this.keyOne = null;
    }

    /** Returns true if field keyOne is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyOne() {
      return this.keyOne != null;
    }

    public void set_keyOne_isSet(boolean value) {
      if (!value) {
        this.keyOne = null;
      }
    }

    public String get_keyTwo() {
      return this.keyTwo;
    }

    public void set_keyTwo(String keyTwo) {
      this.keyTwo = keyTwo;
    }

    public void unset_keyTwo() {
      this.keyTwo = null;
    }

    /** Returns true if field keyTwo is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyTwo() {
      return this.keyTwo != null;
    }

    public void set_keyTwo_isSet(boolean value) {
      if (!value) {
        this.keyTwo = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case KEY_ONE:
        if (value == null) {
          unset_keyOne();
        } else {
          set_keyOne((String)value);
        }
        break;

      case KEY_TWO:
        if (value == null) {
          unset_keyTwo();
        } else {
          set_keyTwo((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case KEY_ONE:
        return get_keyOne();

      case KEY_TWO:
        return get_keyTwo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case KEY_ONE:
        return is_set_keyOne();
      case KEY_TWO:
        return is_set_keyTwo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setUnion_args)
        return this.equals((setUnion_args)that);
      return false;
    }

    public boolean equals(setUnion_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_keyOne = true && this.is_set_keyOne();
      boolean that_present_keyOne = true && that.is_set_keyOne();
      if (this_present_keyOne || that_present_keyOne) {
        if (!(this_present_keyOne && that_present_keyOne))
          return false;
        if (!this.keyOne.equals(that.keyOne))
          return false;
      }

      boolean this_present_keyTwo = true && this.is_set_keyTwo();
      boolean that_present_keyTwo = true && that.is_set_keyTwo();
      if (this_present_keyTwo || that_present_keyTwo) {
        if (!(this_present_keyTwo && that_present_keyTwo))
          return false;
        if (!this.keyTwo.equals(that.keyTwo))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_keyOne = true && (is_set_keyOne());
      builder.append(present_keyOne);
      if (present_keyOne)
        builder.append(keyOne);

      boolean present_keyTwo = true && (is_set_keyTwo());
      builder.append(present_keyTwo);
      if (present_keyTwo)
        builder.append(keyTwo);

      return builder.toHashCode();
    }

    public int compareTo(setUnion_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setUnion_args typedOther = (setUnion_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyOne()).compareTo(typedOther.is_set_keyOne());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyOne()) {
        lastComparison = TBaseHelper.compareTo(this.keyOne, typedOther.keyOne);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyTwo()).compareTo(typedOther.is_set_keyTwo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyTwo()) {
        lastComparison = TBaseHelper.compareTo(this.keyTwo, typedOther.keyTwo);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // KEY_ONE
            if (field.type == TType.STRING) {
              this.keyOne = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // KEY_TWO
            if (field.type == TType.STRING) {
              this.keyTwo = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.keyOne != null) {
        oprot.writeFieldBegin(KEY_ONE_FIELD_DESC);
        oprot.writeString(this.keyOne);
        oprot.writeFieldEnd();
      }
      if (this.keyTwo != null) {
        oprot.writeFieldBegin(KEY_TWO_FIELD_DESC);
        oprot.writeString(this.keyTwo);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setUnion_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyOne:");
      if (this.keyOne == null) {
        sb.append("null");
      } else {
        sb.append(this.keyOne);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyTwo:");
      if (this.keyTwo == null) {
        sb.append("null");
      } else {
        sb.append(this.keyTwo);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setUnion_result implements TBase<setUnion_result, setUnion_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setUnion_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    private List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setUnion_result.class, metaDataMap);
    }

    public setUnion_result() {
    }

    public setUnion_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setUnion_result(setUnion_result other) {
      if (other.is_set_success()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public setUnion_result deepCopy() {
      return new setUnion_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public int get_success_size() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> get_success_iterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void add_to_success(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> get_success() {
      return this.success;
    }

    public void set_success(List<String> success) {
      this.success = success;
    }

    public void unset_success() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return this.success != null;
    }

    public void set_success_isSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return get_success();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setUnion_result)
        return this.equals((setUnion_result)that);
      return false;
    }

    public boolean equals(setUnion_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.is_set_success();
      boolean that_present_success = true && that.is_set_success();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (is_set_success());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(setUnion_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setUnion_result typedOther = (setUnion_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list4 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list4.size);
                for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                {
                  String _elem6;
                  _elem6 = iprot.readString();
                  this.success.add(_elem6);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter7 : this.success)
          {
            oprot.writeString(_iter7);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setUnion_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setIntersection_args implements TBase<setIntersection_args, setIntersection_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setIntersection_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField KEY_ONE_FIELD_DESC = new TField("keyOne", TType.STRING, (short)2);
    private static final TField KEY_TWO_FIELD_DESC = new TField("keyTwo", TType.STRING, (short)3);

    private String domain;
    private String keyOne;
    private String keyTwo;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      KEY_ONE((short)2, "keyOne"),
      KEY_TWO((short)3, "keyTwo");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // KEY_ONE
            return KEY_ONE;
          case 3: // KEY_TWO
            return KEY_TWO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_ONE, new FieldMetaData("keyOne", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY_TWO, new FieldMetaData("keyTwo", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setIntersection_args.class, metaDataMap);
    }

    public setIntersection_args() {
    }

    public setIntersection_args(
      String domain,
      String keyOne,
      String keyTwo)
    {
      this();
      this.domain = domain;
      this.keyOne = keyOne;
      this.keyTwo = keyTwo;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setIntersection_args(setIntersection_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_keyOne()) {
        this.keyOne = other.keyOne;
      }
      if (other.is_set_keyTwo()) {
        this.keyTwo = other.keyTwo;
      }
    }

    public setIntersection_args deepCopy() {
      return new setIntersection_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.keyOne = null;
      this.keyTwo = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_keyOne() {
      return this.keyOne;
    }

    public void set_keyOne(String keyOne) {
      this.keyOne = keyOne;
    }

    public void unset_keyOne() {
      this.keyOne = null;
    }

    /** Returns true if field keyOne is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyOne() {
      return this.keyOne != null;
    }

    public void set_keyOne_isSet(boolean value) {
      if (!value) {
        this.keyOne = null;
      }
    }

    public String get_keyTwo() {
      return this.keyTwo;
    }

    public void set_keyTwo(String keyTwo) {
      this.keyTwo = keyTwo;
    }

    public void unset_keyTwo() {
      this.keyTwo = null;
    }

    /** Returns true if field keyTwo is set (has been asigned a value) and false otherwise */
    public boolean is_set_keyTwo() {
      return this.keyTwo != null;
    }

    public void set_keyTwo_isSet(boolean value) {
      if (!value) {
        this.keyTwo = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case KEY_ONE:
        if (value == null) {
          unset_keyOne();
        } else {
          set_keyOne((String)value);
        }
        break;

      case KEY_TWO:
        if (value == null) {
          unset_keyTwo();
        } else {
          set_keyTwo((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case KEY_ONE:
        return get_keyOne();

      case KEY_TWO:
        return get_keyTwo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case KEY_ONE:
        return is_set_keyOne();
      case KEY_TWO:
        return is_set_keyTwo();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setIntersection_args)
        return this.equals((setIntersection_args)that);
      return false;
    }

    public boolean equals(setIntersection_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_keyOne = true && this.is_set_keyOne();
      boolean that_present_keyOne = true && that.is_set_keyOne();
      if (this_present_keyOne || that_present_keyOne) {
        if (!(this_present_keyOne && that_present_keyOne))
          return false;
        if (!this.keyOne.equals(that.keyOne))
          return false;
      }

      boolean this_present_keyTwo = true && this.is_set_keyTwo();
      boolean that_present_keyTwo = true && that.is_set_keyTwo();
      if (this_present_keyTwo || that_present_keyTwo) {
        if (!(this_present_keyTwo && that_present_keyTwo))
          return false;
        if (!this.keyTwo.equals(that.keyTwo))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_keyOne = true && (is_set_keyOne());
      builder.append(present_keyOne);
      if (present_keyOne)
        builder.append(keyOne);

      boolean present_keyTwo = true && (is_set_keyTwo());
      builder.append(present_keyTwo);
      if (present_keyTwo)
        builder.append(keyTwo);

      return builder.toHashCode();
    }

    public int compareTo(setIntersection_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setIntersection_args typedOther = (setIntersection_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyOne()).compareTo(typedOther.is_set_keyOne());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyOne()) {
        lastComparison = TBaseHelper.compareTo(this.keyOne, typedOther.keyOne);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_keyTwo()).compareTo(typedOther.is_set_keyTwo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_keyTwo()) {
        lastComparison = TBaseHelper.compareTo(this.keyTwo, typedOther.keyTwo);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // KEY_ONE
            if (field.type == TType.STRING) {
              this.keyOne = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // KEY_TWO
            if (field.type == TType.STRING) {
              this.keyTwo = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.keyOne != null) {
        oprot.writeFieldBegin(KEY_ONE_FIELD_DESC);
        oprot.writeString(this.keyOne);
        oprot.writeFieldEnd();
      }
      if (this.keyTwo != null) {
        oprot.writeFieldBegin(KEY_TWO_FIELD_DESC);
        oprot.writeString(this.keyTwo);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setIntersection_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyOne:");
      if (this.keyOne == null) {
        sb.append("null");
      } else {
        sb.append(this.keyOne);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keyTwo:");
      if (this.keyTwo == null) {
        sb.append("null");
      } else {
        sb.append(this.keyTwo);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setIntersection_result implements TBase<setIntersection_result, setIntersection_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setIntersection_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    private List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setIntersection_result.class, metaDataMap);
    }

    public setIntersection_result() {
    }

    public setIntersection_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setIntersection_result(setIntersection_result other) {
      if (other.is_set_success()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public setIntersection_result deepCopy() {
      return new setIntersection_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public int get_success_size() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> get_success_iterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void add_to_success(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> get_success() {
      return this.success;
    }

    public void set_success(List<String> success) {
      this.success = success;
    }

    public void unset_success() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return this.success != null;
    }

    public void set_success_isSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return get_success();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setIntersection_result)
        return this.equals((setIntersection_result)that);
      return false;
    }

    public boolean equals(setIntersection_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.is_set_success();
      boolean that_present_success = true && that.is_set_success();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (is_set_success());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(setIntersection_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setIntersection_result typedOther = (setIntersection_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  String _elem10;
                  _elem10 = iprot.readString();
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter11 : this.success)
          {
            oprot.writeString(_iter11);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setIntersection_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class size_args implements TBase<size_args, size_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("size_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    private String domain;
    private String key;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      KEY((short)2, "key");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // KEY
            return KEY;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(size_args.class, metaDataMap);
    }

    public size_args() {
    }

    public size_args(
      String domain,
      String key)
    {
      this();
      this.domain = domain;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public size_args(size_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_key()) {
        this.key = other.key;
      }
    }

    public size_args deepCopy() {
      return new size_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.key = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_key() {
      return this.key;
    }

    public void set_key(String key) {
      this.key = key;
    }

    public void unset_key() {
      this.key = null;
    }

    /** Returns true if field key is set (has been asigned a value) and false otherwise */
    public boolean is_set_key() {
      return this.key != null;
    }

    public void set_key_isSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unset_key();
        } else {
          set_key((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case KEY:
        return get_key();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case KEY:
        return is_set_key();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof size_args)
        return this.equals((size_args)that);
      return false;
    }

    public boolean equals(size_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_key = true && this.is_set_key();
      boolean that_present_key = true && that.is_set_key();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_key = true && (is_set_key());
      builder.append(present_key);
      if (present_key)
        builder.append(key);

      return builder.toHashCode();
    }

    public int compareTo(size_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      size_args typedOther = (size_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_key()).compareTo(typedOther.is_set_key());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_key()) {
        lastComparison = TBaseHelper.compareTo(this.key, typedOther.key);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // KEY
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("size_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class size_result implements TBase<size_result, size_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("size_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);

    private long success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(size_result.class, metaDataMap);
    }

    public size_result() {
    }

    public size_result(
      long success)
    {
      this();
      this.success = success;
      set_success_isSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public size_result(size_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public size_result deepCopy() {
      return new size_result(this);
    }

    @Override
    public void clear() {
      set_success_isSet(false);
      this.success = 0;
    }

    public long get_success() {
      return this.success;
    }

    public void set_success(long success) {
      this.success = success;
      set_success_isSet(true);
    }

    public void unset_success() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void set_success_isSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(get_success());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof size_result)
        return this.equals((size_result)that);
      return false;
    }

    public boolean equals(size_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true;
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(size_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      size_result typedOther = (size_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              set_success_isSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("size_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiMember_args implements TBase<multiMember_args, multiMember_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("multiMember_args");

    private static final TField DOMAIN_FIELD_DESC = new TField("domain", TType.STRING, (short)1);
    private static final TField SET_KEY_FIELD_DESC = new TField("setKey", TType.STRING, (short)2);
    private static final TField SET_VALS_FIELD_DESC = new TField("setVals", TType.LIST, (short)3);

    private String domain;
    private String setKey;
    private List<String> setVals;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DOMAIN((short)1, "domain"),
      SET_KEY((short)2, "setKey"),
      SET_VALS((short)3, "setVals");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DOMAIN
            return DOMAIN;
          case 2: // SET_KEY
            return SET_KEY;
          case 3: // SET_VALS
            return SET_VALS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DOMAIN, new FieldMetaData("domain", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SET_KEY, new FieldMetaData("setKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SET_VALS, new FieldMetaData("setVals", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(multiMember_args.class, metaDataMap);
    }

    public multiMember_args() {
    }

    public multiMember_args(
      String domain,
      String setKey,
      List<String> setVals)
    {
      this();
      this.domain = domain;
      this.setKey = setKey;
      this.setVals = setVals;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiMember_args(multiMember_args other) {
      if (other.is_set_domain()) {
        this.domain = other.domain;
      }
      if (other.is_set_setKey()) {
        this.setKey = other.setKey;
      }
      if (other.is_set_setVals()) {
        List<String> __this__setVals = new ArrayList<String>();
        for (String other_element : other.setVals) {
          __this__setVals.add(other_element);
        }
        this.setVals = __this__setVals;
      }
    }

    public multiMember_args deepCopy() {
      return new multiMember_args(this);
    }

    @Override
    public void clear() {
      this.domain = null;
      this.setKey = null;
      this.setVals = null;
    }

    public String get_domain() {
      return this.domain;
    }

    public void set_domain(String domain) {
      this.domain = domain;
    }

    public void unset_domain() {
      this.domain = null;
    }

    /** Returns true if field domain is set (has been asigned a value) and false otherwise */
    public boolean is_set_domain() {
      return this.domain != null;
    }

    public void set_domain_isSet(boolean value) {
      if (!value) {
        this.domain = null;
      }
    }

    public String get_setKey() {
      return this.setKey;
    }

    public void set_setKey(String setKey) {
      this.setKey = setKey;
    }

    public void unset_setKey() {
      this.setKey = null;
    }

    /** Returns true if field setKey is set (has been asigned a value) and false otherwise */
    public boolean is_set_setKey() {
      return this.setKey != null;
    }

    public void set_setKey_isSet(boolean value) {
      if (!value) {
        this.setKey = null;
      }
    }

    public int get_setVals_size() {
      return (this.setVals == null) ? 0 : this.setVals.size();
    }

    public java.util.Iterator<String> get_setVals_iterator() {
      return (this.setVals == null) ? null : this.setVals.iterator();
    }

    public void add_to_setVals(String elem) {
      if (this.setVals == null) {
        this.setVals = new ArrayList<String>();
      }
      this.setVals.add(elem);
    }

    public List<String> get_setVals() {
      return this.setVals;
    }

    public void set_setVals(List<String> setVals) {
      this.setVals = setVals;
    }

    public void unset_setVals() {
      this.setVals = null;
    }

    /** Returns true if field setVals is set (has been asigned a value) and false otherwise */
    public boolean is_set_setVals() {
      return this.setVals != null;
    }

    public void set_setVals_isSet(boolean value) {
      if (!value) {
        this.setVals = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DOMAIN:
        if (value == null) {
          unset_domain();
        } else {
          set_domain((String)value);
        }
        break;

      case SET_KEY:
        if (value == null) {
          unset_setKey();
        } else {
          set_setKey((String)value);
        }
        break;

      case SET_VALS:
        if (value == null) {
          unset_setVals();
        } else {
          set_setVals((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DOMAIN:
        return get_domain();

      case SET_KEY:
        return get_setKey();

      case SET_VALS:
        return get_setVals();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DOMAIN:
        return is_set_domain();
      case SET_KEY:
        return is_set_setKey();
      case SET_VALS:
        return is_set_setVals();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiMember_args)
        return this.equals((multiMember_args)that);
      return false;
    }

    public boolean equals(multiMember_args that) {
      if (that == null)
        return false;

      boolean this_present_domain = true && this.is_set_domain();
      boolean that_present_domain = true && that.is_set_domain();
      if (this_present_domain || that_present_domain) {
        if (!(this_present_domain && that_present_domain))
          return false;
        if (!this.domain.equals(that.domain))
          return false;
      }

      boolean this_present_setKey = true && this.is_set_setKey();
      boolean that_present_setKey = true && that.is_set_setKey();
      if (this_present_setKey || that_present_setKey) {
        if (!(this_present_setKey && that_present_setKey))
          return false;
        if (!this.setKey.equals(that.setKey))
          return false;
      }

      boolean this_present_setVals = true && this.is_set_setVals();
      boolean that_present_setVals = true && that.is_set_setVals();
      if (this_present_setVals || that_present_setVals) {
        if (!(this_present_setVals && that_present_setVals))
          return false;
        if (!this.setVals.equals(that.setVals))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_domain = true && (is_set_domain());
      builder.append(present_domain);
      if (present_domain)
        builder.append(domain);

      boolean present_setKey = true && (is_set_setKey());
      builder.append(present_setKey);
      if (present_setKey)
        builder.append(setKey);

      boolean present_setVals = true && (is_set_setVals());
      builder.append(present_setVals);
      if (present_setVals)
        builder.append(setVals);

      return builder.toHashCode();
    }

    public int compareTo(multiMember_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      multiMember_args typedOther = (multiMember_args)other;

      lastComparison = Boolean.valueOf(is_set_domain()).compareTo(typedOther.is_set_domain());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_domain()) {
        lastComparison = TBaseHelper.compareTo(this.domain, typedOther.domain);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_setKey()).compareTo(typedOther.is_set_setKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_setKey()) {
        lastComparison = TBaseHelper.compareTo(this.setKey, typedOther.setKey);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_setVals()).compareTo(typedOther.is_set_setVals());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_setVals()) {
        lastComparison = TBaseHelper.compareTo(this.setVals, typedOther.setVals);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DOMAIN
            if (field.type == TType.STRING) {
              this.domain = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SET_KEY
            if (field.type == TType.STRING) {
              this.setKey = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SET_VALS
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.setVals = new ArrayList<String>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  String _elem14;
                  _elem14 = iprot.readString();
                  this.setVals.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.domain != null) {
        oprot.writeFieldBegin(DOMAIN_FIELD_DESC);
        oprot.writeString(this.domain);
        oprot.writeFieldEnd();
      }
      if (this.setKey != null) {
        oprot.writeFieldBegin(SET_KEY_FIELD_DESC);
        oprot.writeString(this.setKey);
        oprot.writeFieldEnd();
      }
      if (this.setVals != null) {
        oprot.writeFieldBegin(SET_VALS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.setVals.size()));
          for (String _iter15 : this.setVals)
          {
            oprot.writeString(_iter15);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiMember_args(");
      boolean first = true;

      sb.append("domain:");
      if (this.domain == null) {
        sb.append("null");
      } else {
        sb.append(this.domain);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("setKey:");
      if (this.setKey == null) {
        sb.append("null");
      } else {
        sb.append(this.setKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("setVals:");
      if (this.setVals == null) {
        sb.append("null");
      } else {
        sb.append(this.setVals);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class multiMember_result implements TBase<multiMember_result, multiMember_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("multiMember_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    private List<elephantdb.generated.Value> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, elephantdb.generated.Value.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(multiMember_result.class, metaDataMap);
    }

    public multiMember_result() {
    }

    public multiMember_result(
      List<elephantdb.generated.Value> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiMember_result(multiMember_result other) {
      if (other.is_set_success()) {
        List<elephantdb.generated.Value> __this__success = new ArrayList<elephantdb.generated.Value>();
        for (elephantdb.generated.Value other_element : other.success) {
          __this__success.add(new elephantdb.generated.Value(other_element));
        }
        this.success = __this__success;
      }
    }

    public multiMember_result deepCopy() {
      return new multiMember_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public int get_success_size() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<elephantdb.generated.Value> get_success_iterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void add_to_success(elephantdb.generated.Value elem) {
      if (this.success == null) {
        this.success = new ArrayList<elephantdb.generated.Value>();
      }
      this.success.add(elem);
    }

    public List<elephantdb.generated.Value> get_success() {
      return this.success;
    }

    public void set_success(List<elephantdb.generated.Value> success) {
      this.success = success;
    }

    public void unset_success() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return this.success != null;
    }

    public void set_success_isSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((List<elephantdb.generated.Value>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return get_success();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiMember_result)
        return this.equals((multiMember_result)that);
      return false;
    }

    public boolean equals(multiMember_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.is_set_success();
      boolean that_present_success = true && that.is_set_success();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (is_set_success());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public int compareTo(multiMember_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      multiMember_result typedOther = (multiMember_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.success = new ArrayList<elephantdb.generated.Value>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  elephantdb.generated.Value _elem18;
                  _elem18 = new elephantdb.generated.Value();
                  _elem18.read(iprot);
                  this.success.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (elephantdb.generated.Value _iter19 : this.success)
          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiMember_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
